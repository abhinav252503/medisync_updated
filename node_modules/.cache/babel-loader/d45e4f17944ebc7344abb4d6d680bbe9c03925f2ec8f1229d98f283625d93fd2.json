{"ast":null,"code":"// Mock implementations for doctor workflows\nexport const sendDoctorOtp = async doctorId => {\n  console.debug(\"Mock: send OTP to doctor\", doctorId);\n  return Promise.resolve();\n};\nexport const verifyDoctorOtp = async (doctorId, otp) => {\n  console.debug(\"Mock: verify OTP for doctor\", doctorId, otp);\n  if (otp !== '123456') {\n    throw new Error('Invalid OTP');\n  }\n  // login flow: returns doctor profile\n  return Promise.resolve({\n    doctor: {\n      id: doctorId,\n      name: \"Dr. Jane Doe\"\n    }\n  });\n};\n\n// --- NEW: registration mocks ---\n\n// Step 1: register doctor (collect name, email, NMC, phone, etc.)\nexport const registerDoctor = async data => {\n  console.debug(\"Mock: register doctor\", data);\n  // in real: validate NMC/API, send OTP via Twilio\n  return Promise.resolve();\n};\n\n// Step 2: verify doctor signup OTP\nexport const verifyDoctorSignupOtp = async (doctorId, otp) => {\n  console.debug(\"Mock: verify signup OTP\", doctorId, otp);\n  if (otp !== '123456') {\n    throw new Error('Invalid OTP');\n  }\n  // returns same shape as verifyDoctorOtp\n  return Promise.resolve({\n    doctor: {\n      id: doctorId,\n      name: \"Dr. Jane Doe\"\n    }\n  });\n};\n\n// your other mocks…\n\nexport const requestPatientConsent = async patientId => {\n  console.debug(\"Mock: request consent for patient\", patientId);\n  // simulate patient verifying after 2s\n  await new Promise(r => setTimeout(r, 2000));\n  return Promise.resolve({\n    patient: {\n      id: patientId,\n      name: \"John Smith\"\n    }\n  });\n};\nexport const fetchRecords = async (doctorId, patientId) => {\n  console.debug(\"Mock: fetchRecords for\", doctorId, patientId);\n  return Promise.resolve({\n    records: [{\n      id: \"r1\",\n      date: \"2025-06-20\",\n      symptoms: \"Fever, cough\",\n      diagnosis: \"Flu\"\n    }, {\n      id: \"r2\",\n      date: \"2025-05-11\",\n      symptoms: \"Headache\",\n      diagnosis: \"Migraine\"\n    }]\n  });\n};\nexport const saveRecord = async record => {\n  console.debug(\"Mock: saveRecord\", record);\n  return Promise.resolve({\n    success: true\n  });\n};\nexport const fetchAccessHistory = async doctorId => {\n  console.debug(\"Mock: fetchAccessHistory\", doctorId);\n  return Promise.resolve({\n    history: [{\n      time: \"2025-06-22 10:00\",\n      patientId: \"p1\",\n      action: \"view\",\n      location: \"Hospital\"\n    }, {\n      time: \"2025-06-21 15:30\",\n      patientId: \"p2\",\n      action: \"upload\",\n      location: \"Home Clinic\"\n    }]\n  });\n};","map":{"version":3,"names":["sendDoctorOtp","doctorId","console","debug","Promise","resolve","verifyDoctorOtp","otp","Error","doctor","id","name","registerDoctor","data","verifyDoctorSignupOtp","requestPatientConsent","patientId","r","setTimeout","patient","fetchRecords","records","date","symptoms","diagnosis","saveRecord","record","success","fetchAccessHistory","history","time","action","location"],"sources":["D:/medsync/medisync-frontend/src/services/doctorApi.js"],"sourcesContent":["// Mock implementations for doctor workflows\r\nexport const sendDoctorOtp = async (doctorId) => {\r\n  console.debug(\"Mock: send OTP to doctor\", doctorId);\r\n  return Promise.resolve();\r\n};\r\n\r\nexport const verifyDoctorOtp = async (doctorId, otp) => {\r\n  console.debug(\"Mock: verify OTP for doctor\", doctorId, otp);\r\n  if (otp !== '123456') {\r\n    throw new Error('Invalid OTP');\r\n  }\r\n  // login flow: returns doctor profile\r\n  return Promise.resolve({ doctor: { id: doctorId, name: \"Dr. Jane Doe\" } });\r\n};\r\n\r\n// --- NEW: registration mocks ---\r\n\r\n// Step 1: register doctor (collect name, email, NMC, phone, etc.)\r\nexport const registerDoctor = async (data) => {\r\n  console.debug(\"Mock: register doctor\", data);\r\n  // in real: validate NMC/API, send OTP via Twilio\r\n  return Promise.resolve();\r\n};\r\n\r\n// Step 2: verify doctor signup OTP\r\nexport const verifyDoctorSignupOtp = async (doctorId, otp) => {\r\n  console.debug(\"Mock: verify signup OTP\", doctorId, otp);\r\n  if (otp !== '123456') {\r\n    throw new Error('Invalid OTP');\r\n  }\r\n  // returns same shape as verifyDoctorOtp\r\n  return Promise.resolve({ doctor: { id: doctorId, name: \"Dr. Jane Doe\" } });\r\n};\r\n\r\n// your other mocks…\r\n\r\nexport const requestPatientConsent = async (patientId) => {\r\n  console.debug(\"Mock: request consent for patient\", patientId);\r\n  // simulate patient verifying after 2s\r\n  await new Promise(r => setTimeout(r, 2000));\r\n  return Promise.resolve({ patient: { id: patientId, name: \"John Smith\" } });\r\n};\r\n\r\nexport const fetchRecords = async (doctorId, patientId) => {\r\n  console.debug(\"Mock: fetchRecords for\", doctorId, patientId);\r\n  return Promise.resolve({\r\n    records: [\r\n      { id: \"r1\", date: \"2025-06-20\", symptoms: \"Fever, cough\", diagnosis: \"Flu\", },\r\n      { id: \"r2\", date: \"2025-05-11\", symptoms: \"Headache\", diagnosis: \"Migraine\" },\r\n    ]\r\n  });\r\n};\r\n\r\nexport const saveRecord = async (record) => {\r\n  console.debug(\"Mock: saveRecord\", record);\r\n  return Promise.resolve({ success: true });\r\n};\r\n\r\nexport const fetchAccessHistory = async (doctorId) => {\r\n  console.debug(\"Mock: fetchAccessHistory\", doctorId);\r\n  return Promise.resolve({\r\n    history: [\r\n      { time: \"2025-06-22 10:00\", patientId: \"p1\", action: \"view\", location: \"Hospital\" },\r\n      { time: \"2025-06-21 15:30\", patientId: \"p2\", action: \"upload\", location: \"Home Clinic\" },\r\n    ]\r\n  });\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}